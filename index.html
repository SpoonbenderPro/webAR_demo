<!-- ... head and body stay same ... -->

<script type="module">
  import * as THREE from 'three';
  import { MindARThree } from 'mindar-image-three';

  const CTA_URL = 'https://example.com';
  document.getElementById('ctaBtn').href = CTA_URL;

  const container = document.getElementById('container');
  const startBtn  = document.getElementById('startBtn');
  const restartBtn= document.getElementById('restartBtn');
  const muteBtn   = document.getElementById('muteBtn');
  const videoEl   = document.getElementById('hiddenVideo');
  const hint      = document.getElementById('hint');
  const nudge     = document.getElementById('nudge');

  const mindar = new MindARThree({
    container,
    imageTargetSrc: './targets.mind',
    uiLoading:'no', uiScanning:'no', uiError:'no',
    warmupTolerance: 2, missTolerance: 8
  });
  const { renderer, scene, camera } = mindar;
  renderer.setClearColor(0x000000, 0);
  renderer.domElement.style.touchAction = 'none';
  scene.add(new THREE.AmbientLight(0xffffff, 1));

  // 🎥 Video texture + plane (fixed 16:9 ratio)
  const videoTex = new THREE.VideoTexture(videoEl);
  videoTex.encoding = THREE.sRGBEncoding;
  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(1.78, 1), // ✅ exactly 1920x1080 ratio
    new THREE.MeshBasicMaterial({ 
      map: videoTex, 
      side: THREE.DoubleSide, 
      toneMapped:false, 
      transparent:true 
    })
  );

  // ❌ Removed loadedmetadata scaling — not needed anymore

  // Anchor on target index 0
  const anchor = mindar.addAnchor(0);
  anchor.group.add(plane);

  // 🔁 Stick-to-camera mode
  const placeInFrontOfCamera = () => {
    camera.add(plane);
    plane.position.set(0, 0, -1.0);
    plane.rotation.set(0, 0, 0);
    plane.visible = true;
  };
  const placeOnAnchor = () => {
    plane.position.set(0,0,0);
    plane.rotation.set(0,0,0);
    anchor.group.add(plane);
    plane.visible = true;
  };

  anchor.onTargetFound = () => {
    hint.textContent = 'Tracking ✓';
    placeOnAnchor();
    if (videoEl.paused) videoEl.play().catch(()=>{ showNudge(); });
  };
  anchor.onTargetLost = () => {
    hint.textContent = 'Move back to the target…';
    placeInFrontOfCamera();
  };

  // UI controls
  const setMuteUI = () => { muteBtn.textContent = videoEl.muted ? 'Unmute' : 'Mute'; };
  const showNudge = () => { nudge.style.display='block'; setTimeout(()=> nudge.style.display='none', 2000); };
  setMuteUI();

  muteBtn.addEventListener('click', async () => {
    videoEl.muted = !videoEl.muted; setMuteUI();
    try { await videoEl.play(); } catch { showNudge(); }
  });

  restartBtn.addEventListener('click', async () => {
    try { await mindar.stop(); } catch {}
    await mindar.start();
  });

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true; startBtn.textContent = 'Starting…';
    videoEl.muted = true; try { await videoEl.play(); } catch {} videoEl.pause();

    try {
      await mindar.start();
      renderer.setAnimationLoop(()=>renderer.render(scene, camera));
      startBtn.textContent = 'Running…';
    } catch (e) {
      console.error(e);
      startBtn.disabled = false; startBtn.textContent = 'Start AR (Retry)';
    }
  });

  const ro = new ResizeObserver(() => {
    renderer.setSize(container.clientWidth, container.clientHeight, false);
  });
  ro.observe(container);
</script>
